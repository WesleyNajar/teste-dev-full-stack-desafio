#!/bin/bash

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Fun√ß√£o para imprimir mensagens coloridas
print_message() {
    echo -e "${2}${1}${NC}"
}

print_header() {
    echo ""
    print_message "üöÄ CONFIGURA√á√ÉO AUTOM√ÅTICA DO AMBIENTE" "$PURPLE"
    print_message "=====================================" "$PURPLE"
    echo ""
}

print_step() {
    print_message "üìã $1" "$BLUE"
}

print_success() {
    print_message "‚úÖ $1" "$GREEN"
}

print_warning() {
    print_message "‚ö†Ô∏è  $1" "$YELLOW"
}

print_error() {
    print_message "‚ùå $1" "$RED"
}

# Fun√ß√£o para verificar se comando existe
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Fun√ß√£o para aguardar servi√ßo ficar dispon√≠vel
wait_for_service() {
    local url=$1
    local service_name=$2
    local max_attempts=30
    local attempt=1
    
    print_step "Aguardando $service_name ficar dispon√≠vel..."
    
    while [ $attempt -le $max_attempts ]; do
        if curl -s "$url" > /dev/null 2>&1; then
            print_success "$service_name est√° dispon√≠vel!"
            return 0
        fi
        
        echo -n "."
        sleep 2
        attempt=$((attempt + 1))
    done
    
    print_warning "$service_name n√£o respondeu ap√≥s $max_attempts tentativas"
    return 1
}

# Fun√ß√£o para verificar se porta est√° em uso
check_port() {
    local port=$1
    local service=$2
    
    if command_exists netstat; then
        if netstat -tuln 2>/dev/null | grep -q ":$port "; then
            print_warning "Porta $port est√° em uso. Verifique se $service n√£o est√° rodando."
            return 1
        fi
    elif command_exists ss; then
        if ss -tuln 2>/dev/null | grep -q ":$port "; then
            print_warning "Porta $port est√° em uso. Verifique se $service n√£o est√° rodando."
            return 1
        fi
    fi
    
    return 0
}

# Fun√ß√£o para criar arquivos .env se n√£o existirem
create_env_files() {
    print_step "Verificando arquivos de ambiente..."
    
    # Backend .env
    if [ ! -f "backend/.env" ]; then
        if [ -f "backend/env.example" ]; then
            cp backend/env.example backend/.env
            print_success "Arquivo backend/.env criado a partir do exemplo"
        else
            print_warning "Arquivo backend/env.example n√£o encontrado"
        fi
    else
        print_success "Arquivo backend/.env j√° existe"
    fi
    
    # Frontend .env
    if [ ! -f "frontend/.env" ]; then
        if [ -f "frontend/env.example" ]; then
            cp frontend/env.example frontend/.env
            print_success "Arquivo frontend/.env criado a partir do exemplo"
        else
            print_warning "Arquivo frontend/env.example n√£o encontrado"
        fi
    else
        print_success "Arquivo frontend/.env j√° existe"
    fi
}

# Fun√ß√£o para verificar e corrigir problemas conhecidos
check_and_fix_known_issues() {
    print_step "Verificando problemas conhecidos..."
    
    # Verificar se composer.lock existe
    if [ ! -f "backend/composer.lock" ]; then
        print_warning "composer.lock n√£o encontrado. Gerando automaticamente..."
        generate_composer_lock
    fi
    
    # Verificar se composer.json tem predis
    if ! grep -q "predis/predis" backend/composer.json; then
        print_warning "Depend√™ncia predis/predis n√£o encontrada. Adicionando..."
        fix_composer_issues
    fi
    
    # Verificar se env.example tem configura√ß√£o Redis correta
    if ! grep -q "REDIS_CLIENT=predis" backend/env.example; then
        print_warning "Configura√ß√£o Redis incorreta. Corrigindo..."
        fix_redis_issues
    fi
    
    # Verificar se composer.lock est√° desatualizado
    if [ -f "backend/composer.lock" ] && [ "backend/composer.json" -nt "backend/composer.lock" ]; then
        print_warning "composer.lock est√° desatualizado. Regenerando..."
        generate_composer_lock
    fi
    
    print_success "Verifica√ß√£o de problemas conclu√≠da"
}

# Fun√ß√£o para verificar depend√™ncias
check_dependencies() {
    print_step "Verificando depend√™ncias..."
    
    # Verificar Docker
    if ! command_exists docker; then
        print_error "Docker n√£o est√° instalado. Instale o Docker Desktop primeiro."
        exit 1
    fi
    
    # Verificar Docker Compose
    if ! command_exists docker-compose && ! docker compose version >/dev/null 2>&1; then
        print_error "Docker Compose n√£o est√° instalado."
        exit 1
    fi
    
    # Verificar se Docker est√° rodando
    if ! docker info > /dev/null 2>&1; then
        print_error "Docker n√£o est√° rodando. Inicie o Docker Desktop primeiro."
        exit 1
    fi
    
    print_success "Todas as depend√™ncias est√£o instaladas"
}

# Fun√ß√£o para verificar portas
check_ports() {
    print_step "Verificando portas dispon√≠veis..."
    
    local ports=(80 3000 5432 5050 6379)
    local services=("Nginx" "Vue.js" "PostgreSQL" "pgAdmin" "Redis")
    
    for i in "${!ports[@]}"; do
        if ! check_port "${ports[$i]}" "${services[$i]}"; then
            print_warning "Porta ${ports[$i]} (${services[$i]}) est√° em uso"
        fi
    done
}

# Fun√ß√£o para limpar ambiente anterior
cleanup_environment() {
    print_step "Limpando ambiente anterior..."
    
    # Parar containers existentes
    docker-compose down --remove-orphans 2>/dev/null || true
    
    # Remover volumes √≥rf√£os (opcional)
    docker volume prune -f 2>/dev/null || true
    
    print_success "Ambiente anterior limpo"
}

# Fun√ß√£o para corrigir problemas de composer
fix_composer_issues() {
    print_step "Corrigendo problemas de depend√™ncias do Composer..."
    
    # Verificar se composer.lock existe
    if [ ! -f "backend/composer.lock" ]; then
        print_message "composer.lock n√£o encontrado. Gerando automaticamente..." "$YELLOW"
        generate_composer_lock
        return
    fi
    
    # Verificar se composer.lock est√° desatualizado
    if [ "backend/composer.json" -nt "backend/composer.lock" ]; then
        print_message "composer.lock est√° desatualizado. Regenerando..." "$YELLOW"
        rm backend/composer.lock
        generate_composer_lock
        return
    fi
    
    # Verificar se composer.json tem predis
    if grep -q "predis/predis" backend/composer.json; then
        print_message "Depend√™ncia predis/predis encontrada no composer.json" "$GREEN"
    else
        print_message "Adicionando predis/predis ao composer.json..." "$YELLOW"
        # Adicionar predis se n√£o existir
        sed -i 's/"laravel\/tinker": "^2.10.1"/"laravel\/tinker": "^2.10.1",\n        "predis\/predis": "^2.2"/' backend/composer.json
        # Regenerar composer.lock ap√≥s adicionar depend√™ncia
        generate_composer_lock
    fi
    
    print_success "Problemas de Composer corrigidos"
}

# Fun√ß√£o para gerar composer.lock
generate_composer_lock() {
    print_step "Gerando composer.lock..."
    
    # Verificar se composer est√° dispon√≠vel
    if ! command_exists composer; then
        print_warning "Composer n√£o est√° dispon√≠vel localmente. Ser√° gerado no container."
        return
    fi
    
    # Gerar composer.lock localmente
    cd backend
    
    # Primeiro tentar composer install
    if composer install --no-dev --optimize-autoloader --no-interaction --ignore-platform-reqs; then
        print_success "composer.lock gerado com sucesso via composer install"
        cd ..
        return
    fi
    
    # Se falhar, tentar composer update
    print_warning "composer install falhou. Tentando composer update..."
    if composer update --no-dev --optimize-autoloader --no-interaction --ignore-platform-reqs; then
        print_success "composer.lock gerado com sucesso via composer update"
        cd ..
        return
    fi
    
    # Se ainda falhar, tentar apenas composer install sem flags
    print_warning "composer update falhou. Tentando composer install b√°sico..."
    if composer install --ignore-platform-reqs; then
        print_success "composer.lock gerado com sucesso via composer install b√°sico"
        cd ..
        return
    fi
    
    # Se tudo falhar
    print_warning "Falha ao gerar composer.lock localmente. Ser√° gerado no container."
    cd ..
}

# Fun√ß√£o para corrigir problemas de Redis
fix_redis_issues() {
    print_step "Corrigindo problemas de Redis..."
    
    # Verificar se env.example tem configura√ß√£o Redis correta
    if grep -q "REDIS_CLIENT=predis" backend/env.example; then
        print_message "Configura√ß√£o Redis j√° est√° correta" "$GREEN"
    else
        print_message "Corrigindo configura√ß√£o Redis..." "$YELLOW"
        # Substituir phpredis por predis
        sed -i 's/REDIS_CLIENT=phpredis/REDIS_CLIENT=predis/' backend/env.example
    fi
    
    print_success "Problemas de Redis corrigidos"
}

# Fun√ß√£o para construir e iniciar containers
build_and_start() {
    print_step "Construindo e iniciando containers..."
    
    # Tentar construir containers
    if docker-compose up --build -d; then
        print_success "Containers constru√≠dos e iniciados"
    else
        print_warning "Falha na primeira tentativa de build. Tentando corre√ß√µes autom√°ticas..."
        
        # Verificar se √© erro de composer.lock ou depend√™ncias
        if docker-compose logs backend 2>/dev/null | grep -q "lock file is not up to date\|Class.*not found\|predis"; then
            print_step "Detectado problema com depend√™ncias do Composer. Aplicando corre√ß√£o..."
            fix_composer_issues
        fi
        
        # Verificar se √© erro de extens√£o Redis
        if docker-compose logs backend 2>/dev/null | grep -q "redis"; then
            print_step "Detectado problema com Redis. Aplicando corre√ß√£o..."
            fix_redis_issues
        fi
        
        # Tentar novamente ap√≥s corre√ß√µes
        print_step "Tentando build novamente ap√≥s corre√ß√µes..."
        if docker-compose up --build -d; then
            print_success "Containers constru√≠dos e iniciados ap√≥s corre√ß√µes"
        else
            print_error "Falha ao construir/iniciar containers mesmo ap√≥s corre√ß√µes"
            print_warning "Verifique os logs: docker-compose logs backend"
            exit 1
        fi
    fi
}

# Fun√ß√£o para aguardar servi√ßos ficarem prontos
wait_for_services() {
    print_step "Aguardando servi√ßos ficarem prontos..."
    
    # Aguardar PostgreSQL
    local max_attempts=60
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if docker-compose exec -T postgres pg_isready -U laravel_user >/dev/null 2>&1; then
            print_success "PostgreSQL est√° pronto"
            break
        fi
        
        echo -n "."
        sleep 2
        attempt=$((attempt + 1))
        
        if [ $attempt -gt $max_attempts ]; then
            print_error "PostgreSQL n√£o ficou pronto a tempo"
            exit 1
        fi
    done
    
    # Aguardar um pouco mais para garantir que todos os servi√ßos estejam prontos
    sleep 10
}

# Fun√ß√£o para verificar e instalar Predis
ensure_predis_installed() {
    print_step "Verificando instala√ß√£o do Predis..."
    
    # Aguardar o container backend ficar pronto
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if docker-compose exec -T backend php --version >/dev/null 2>&1; then
            print_success "Container backend est√° pronto"
            break
        fi
        
        echo -n "."
        sleep 2
        attempt=$((attempt + 1))
        
        if [ $attempt -gt $max_attempts ]; then
            print_warning "Container backend n√£o ficou pronto a tempo"
            return 1
        fi
    done
    
    # Verificar se Predis est√° instalado
    if ! docker-compose exec -T backend composer show predis/predis >/dev/null 2>&1; then
        print_warning "Predis n√£o encontrado. Instalando..."
        if docker-compose exec -T backend composer require predis/predis; then
            print_success "Predis instalado com sucesso"
        else
            print_error "Falha ao instalar Predis"
            return 1
        fi
    else
        print_success "Predis j√° est√° instalado"
    fi
    
    return 0
}

# Fun√ß√£o para configurar Laravel
configure_laravel() {
    print_step "Configurando Laravel..."
    
    # Gerar chave da aplica√ß√£o
    if docker-compose exec -T backend php artisan key:generate --force; then
        print_success "Chave da aplica√ß√£o gerada"
    else
        print_warning "Falha ao gerar chave da aplica√ß√£o"
    fi
    
    # Limpar cache
    docker-compose exec -T backend php artisan config:clear 2>/dev/null || true
    docker-compose exec -T backend php artisan cache:clear 2>/dev/null || true
    docker-compose exec -T backend php artisan route:clear 2>/dev/null || true
    
    print_success "Laravel configurado"
}

# Fun√ß√£o para executar migrations e seeders
setup_database() {
    print_step "Configurando banco de dados..."
    
    # Executar migrations
    if docker-compose exec -T backend php artisan migrate:fresh --force; then
        print_success "Migrations executadas"
    else
        print_error "Falha ao executar migrations"
        exit 1
    fi
    
    # Executar seeders
    if docker-compose exec -T backend php artisan db:seed --force; then
        print_success "Seeders executados"
    else
        print_warning "Falha ao executar seeders"
    fi
}

# Fun√ß√£o para instalar depend√™ncias do frontend
install_frontend_deps() {
    print_step "Instalando depend√™ncias do frontend..."
    
    if docker-compose exec -T frontend npm install; then
        print_success "Depend√™ncias do frontend instaladas"
    else
        print_warning "Falha ao instalar depend√™ncias do frontend"
    fi
}

# Fun√ß√£o para verificar status dos containers
check_containers_status() {
    print_step "Verificando status dos containers..."
    
    echo ""
    docker-compose ps
    echo ""
    
    # Verificar se todos os containers est√£o rodando
    local containers=("backend" "frontend" "nginx" "postgres" "pgadmin" "redis")
    local all_running=true
    
    for container in "${containers[@]}"; do
        if ! docker-compose ps "$container" | grep -q "Up"; then
            print_warning "Container $container n√£o est√° rodando"
            all_running=false
        fi
    done
    
    if [ "$all_running" = true ]; then
        print_success "Todos os containers est√£o rodando"
    else
        print_warning "Alguns containers podem n√£o estar rodando corretamente"
    fi
}

# Fun√ß√£o para testar conectividade
test_connectivity() {
    print_step "Testando conectividade dos servi√ßos..."
    
    # Aguardar um pouco mais para garantir que os servi√ßos estejam prontos
    sleep 5
    
    # Testar API Laravel
    echo -n "   API Laravel: "
    if curl -s -f http://localhost/api >/dev/null 2>&1; then
        print_success "API est√° respondendo"
    else
        print_warning "API n√£o est√° respondendo (pode ser normal se n√£o houver rota /api)"
    fi
    
    # Testar Frontend
    echo -n "   Frontend Vue.js: "
    if curl -s -f http://localhost >/dev/null 2>&1; then
        print_success "Frontend est√° respondendo"
    else
        print_warning "Frontend n√£o est√° respondendo"
    fi
    
    # Testar pgAdmin
    echo -n "   pgAdmin: "
    if curl -s -f http://localhost:5050 >/dev/null 2>&1; then
        print_success "pgAdmin est√° respondendo"
    else
        print_warning "pgAdmin n√£o est√° respondendo"
    fi
}

# Fun√ß√£o para exibir informa√ß√µes finais
show_final_info() {
    echo ""
    print_message "üéâ CONFIGURA√á√ÉO CONCLU√çDA COM SUCESSO!" "$GREEN"
    echo ""
    print_message "üåê URLs de acesso:" "$CYAN"
    echo "   Frontend (Vue.js): http://localhost"
    echo "   Backend (Laravel API): http://localhost/api"
    echo "   pgAdmin: http://localhost:5050"
    echo ""
    print_message "üìù Credenciais pgAdmin:" "$CYAN"
    echo "   Email: admin@admin.com"
    echo "   Senha: admin"
    echo ""
    print_message "üìä Dados de teste criados:" "$CYAN"
    echo "   - 3 usu√°rios"
    echo "   - 5 produtos"
    echo "   - Relacionamentos configurados"
    echo ""
    print_message "üîß Comandos √∫teis:" "$CYAN"
    echo "   Ver logs: docker-compose logs -f"
    echo "   Parar ambiente: docker-compose down"
    echo "   Reconstruir: docker-compose up --build -d"
    echo "   Status: docker-compose ps"
    echo ""
    print_message "üìã Para desenvolvimento:" "$CYAN"
    echo "   Backend: docker-compose exec backend bash"
    echo "   Frontend: docker-compose exec frontend sh"
    echo "   Database: docker-compose exec postgres psql -U laravel_user -d laravel_app"
    echo ""
    print_message "üöÄ O ambiente est√° pronto para uso!" "$GREEN"
}

# Fun√ß√£o principal
main() {
    print_header
    
    # Verifica√ß√µes iniciais
    check_dependencies
    check_ports
    create_env_files
    check_and_fix_known_issues
    
    # Configura√ß√£o do ambiente
    cleanup_environment
    build_and_start
    wait_for_services
    
    # Verificar e instalar Predis
    ensure_predis_installed
    
    # Configura√ß√£o das aplica√ß√µes
    configure_laravel
    setup_database
    install_frontend_deps
    
    # Verifica√ß√µes finais
    check_containers_status
    test_connectivity
    show_final_info
}

# Executar fun√ß√£o principal
main "$@"
